# Widget Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a self-contained embeddable chat widget (`public/widget.js`) that customers drop into any site via two script tags, featuring a floating bubble, slide-up drawer, SSE streaming, and browser action execution (navigate / open_tab).

**Architecture:** Separate `widget/` package at repo root using Vite library mode + Preact. Widget mounts into a shadow DOM root so customer styles never interfere. Entry reads `window.ImplyConfig`, mounts components, and exposes `window.Imply` public API.

**Tech Stack:** Preact 10, Vite 5, TypeScript strict, shadow DOM, `sessionStorage` for conversation persistence.

---

## Task 1: Scaffold `widget/` package

**Files:**
- Create: `widget/package.json`
- Create: `widget/tsconfig.json`
- Create: `widget/vite.config.ts`

**Step 1: Create `widget/package.json`**

```json
{
  "name": "@imply/widget",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "build": "vite build",
    "dev": "vite build --watch"
  },
  "dependencies": {
    "preact": "^10.19.0"
  },
  "devDependencies": {
    "vite": "^5.2.0",
    "@preact/preset-vite": "^2.8.0",
    "typescript": "^5.4.0"
  }
}
```

**Step 2: Create `widget/tsconfig.json`**

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "jsx": "react-jsx",
    "jsxImportSource": "preact",
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "lib": ["ES2020", "DOM"],
    "outDir": "dist",
    "declaration": true
  },
  "include": ["src"]
}
```

**Step 3: Create `widget/vite.config.ts`**

```typescript
import { defineConfig } from 'vite'
import preact from '@preact/preset-vite'
import { resolve } from 'path'

export default defineConfig({
  plugins: [preact()],
  build: {
    lib: {
      entry:    resolve(__dirname, 'src/index.ts'),
      name:     'Imply',
      fileName: 'widget',
      formats:  ['iife'],
    },
    outDir:          '../../public',
    emptyOutDir:     false,
    minify:          true,
    rollupOptions: {
      output: {
        entryFileNames: 'widget.js',
      },
    },
  },
})
```

**Step 4: Install widget dependencies**

```bash
cd widget && pnpm install
```

Expected: `node_modules/preact` present.

**Step 5: Add build script to root `package.json`**

In the root `package.json` `scripts` object, add:
```json
"build:widget": "pnpm --filter @imply/widget build"
```

Also add `widget` to the `pnpm-workspace.yaml` if it exists, or create it:
```yaml
packages:
  - 'widget'
```

**Step 6: Commit**

```bash
git add widget/ pnpm-workspace.yaml package.json
git commit -m "feat: scaffold widget package with Vite + Preact"
```

---

## Task 2: Styles

**Files:**
- Create: `widget/src/styles.ts`

The widget injects a single CSS string into the shadow root. All selectors are scoped because shadow DOM creates a boundary.

**Step 1: Create `widget/src/styles.ts`**

```typescript
export const STYLES = `
  :host {
    all: initial;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    font-size: 14px;
    line-height: 1.5;
    color: #111;
    box-sizing: border-box;
  }

  *, *::before, *::after { box-sizing: inherit; }

  /* Bubble */
  .imply-bubble {
    position: fixed;
    bottom: 24px;
    right: 24px;
    width: 56px;
    height: 56px;
    border-radius: 50%;
    background: #111;
    color: #fff;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 16px rgba(0,0,0,0.18);
    transition: opacity 0.15s;
    z-index: 999999;
  }
  .imply-bubble:hover { opacity: 0.85; }
  .imply-bubble.left { right: auto; left: 24px; }

  @keyframes imply-pulse {
    0%   { box-shadow: 0 0 0 0 rgba(17,17,17,0.4); }
    70%  { box-shadow: 0 0 0 10px rgba(17,17,17,0); }
    100% { box-shadow: 0 0 0 0 rgba(17,17,17,0); }
  }
  .imply-bubble.pulse { animation: imply-pulse 1.5s ease-out 1; }

  /* Drawer */
  .imply-drawer {
    position: fixed;
    bottom: 92px;
    right: 24px;
    width: 380px;
    height: 560px;
    background: #faf8f5;
    border: 1px solid #e5e1db;
    border-radius: 16px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.12);
    display: flex;
    flex-direction: column;
    z-index: 999998;
    transform: translateY(20px);
    opacity: 0;
    pointer-events: none;
    transition: transform 0.25s ease-out, opacity 0.25s ease-out;
  }
  .imply-drawer.open {
    transform: translateY(0);
    opacity: 1;
    pointer-events: all;
  }
  .imply-drawer.left { right: auto; left: 24px; }

  @media (max-width: 640px) {
    .imply-drawer {
      width: 100vw;
      height: 65vh;
      bottom: 0;
      right: 0;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
    }
    .imply-drawer.left { left: 0; }
    .imply-bubble { bottom: 16px; right: 16px; }
    .imply-bubble.left { right: auto; left: 16px; }
  }

  /* Drawer header */
  .imply-header {
    background: #111;
    color: #fff;
    padding: 14px 16px;
    border-radius: 14px 14px 0 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
  }
  .imply-header-title { font-weight: 600; font-size: 14px; }
  .imply-header-actions { display: flex; gap: 4px; }
  .imply-header-btn {
    background: transparent;
    border: none;
    color: rgba(255,255,255,0.7);
    cursor: pointer;
    padding: 4px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    transition: color 0.15s;
  }
  .imply-header-btn:hover { color: #fff; }

  /* Message list */
  .imply-messages {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .imply-messages::-webkit-scrollbar { width: 4px; }
  .imply-messages::-webkit-scrollbar-thumb { background: #e5e1db; border-radius: 2px; }

  /* Message bubbles */
  .imply-msg { display: flex; flex-direction: column; max-width: 80%; }
  .imply-msg.user { align-self: flex-end; align-items: flex-end; }
  .imply-msg.assistant { align-self: flex-start; align-items: flex-start; }

  .imply-msg-bubble {
    padding: 10px 14px;
    border-radius: 16px;
    font-size: 14px;
    line-height: 1.5;
    word-break: break-word;
  }
  .imply-msg.user .imply-msg-bubble {
    background: #111;
    color: #fff;
    border-bottom-right-radius: 4px;
  }
  .imply-msg.assistant .imply-msg-bubble {
    background: #f0ebe4;
    color: #111;
    border-bottom-left-radius: 4px;
  }

  /* Typing dots */
  .imply-typing { display: flex; gap: 4px; padding: 14px; }
  .imply-typing span {
    width: 6px; height: 6px;
    background: #999;
    border-radius: 50%;
    animation: imply-bounce 1.2s infinite;
  }
  .imply-typing span:nth-child(2) { animation-delay: 0.2s; }
  .imply-typing span:nth-child(3) { animation-delay: 0.4s; }
  @keyframes imply-bounce {
    0%, 80%, 100% { transform: translateY(0); }
    40%           { transform: translateY(-6px); }
  }

  /* Sources */
  .imply-sources {
    margin-top: 6px;
    font-size: 12px;
    color: #888;
    cursor: pointer;
    user-select: none;
  }
  .imply-sources-list {
    margin-top: 4px;
    padding: 8px 10px;
    background: #fff;
    border: 1px solid #e5e1db;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  .imply-source-item { font-size: 11px; color: #555; }

  /* Input bar */
  .imply-input-bar {
    padding: 12px;
    border-top: 1px solid #e5e1db;
    display: flex;
    gap: 8px;
    align-items: flex-end;
    flex-shrink: 0;
  }
  .imply-textarea {
    flex: 1;
    border: 1px solid #e5e1db;
    border-radius: 10px;
    padding: 8px 12px;
    font-size: 14px;
    font-family: inherit;
    resize: none;
    outline: none;
    background: #fff;
    color: #111;
    min-height: 38px;
    max-height: 96px;
    overflow-y: auto;
    line-height: 1.5;
    transition: border-color 0.15s;
  }
  .imply-textarea:focus { border-color: #111; }
  .imply-textarea:disabled { opacity: 0.5; cursor: not-allowed; }
  .imply-send-btn {
    width: 36px;
    height: 36px;
    background: #111;
    border: none;
    border-radius: 8px;
    color: #fff;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: opacity 0.15s;
  }
  .imply-send-btn:disabled { opacity: 0.4; cursor: not-allowed; }
  .imply-send-btn:not(:disabled):hover { opacity: 0.8; }

  /* Error */
  .imply-error {
    font-size: 12px;
    color: #dc2626;
    padding: 4px 14px 8px;
    text-align: center;
  }
`
```

**Step 2: Commit**

```bash
git add widget/src/styles.ts
git commit -m "feat: add widget shadow DOM styles"
```

---

## Task 3: `useChat` hook (with tests)

**Files:**
- Create: `widget/src/hooks/useChat.ts`
- Create: `widget/src/hooks/useChat.test.ts`

The hook manages all chat state and SSE parsing. It is the only pure-logic unit in the widget — test it thoroughly.

**Step 1: Write the failing tests**

Create `widget/src/hooks/useChat.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { parseSSELine } from './useChat'

describe('parseSSELine', () => {
  it('returns null for empty line', () => {
    expect(parseSSELine('')).toBeNull()
  })

  it('returns null for lines without data: prefix', () => {
    expect(parseSSELine('event: something')).toBeNull()
  })

  it('parses a delta event', () => {
    const line = 'data: {"type":"delta","text":"hello"}'
    expect(parseSSELine(line)).toEqual({ type: 'delta', text: 'hello' })
  })

  it('parses a done event', () => {
    const line = 'data: {"type":"done","messageId":"m1","conversationId":"c1"}'
    expect(parseSSELine(line)).toEqual({ type: 'done', messageId: 'm1', conversationId: 'c1' })
  })

  it('parses a sources event', () => {
    const line = 'data: {"type":"sources","data":[{"filename":"doc.pdf","score":0.9}]}'
    const result = parseSSELine(line)
    expect(result?.type).toBe('sources')
  })

  it('parses a navigate action event', () => {
    const line = 'data: {"type":"action","action":{"kind":"navigate","url":"/billing"}}'
    expect(parseSSELine(line)).toEqual({
      type: 'action',
      action: { kind: 'navigate', url: '/billing' }
    })
  })

  it('parses an open_tab action event', () => {
    const line = 'data: {"type":"action","action":{"kind":"open_tab","url":"https://docs.example.com"}}'
    const result = parseSSELine(line)
    expect(result).toEqual({
      type: 'action',
      action: { kind: 'open_tab', url: 'https://docs.example.com' }
    })
  })

  it('returns null for malformed JSON', () => {
    expect(parseSSELine('data: {broken')).toBeNull()
  })
})
```

**Step 2: Add vitest to widget devDependencies and run test**

In `widget/package.json`, add to `devDependencies`:
```json
"vitest": "^1.4.0"
```

Add to `scripts`:
```json
"test": "vitest run"
```

Run:
```bash
cd widget && pnpm install && pnpm test
```
Expected: FAIL — `parseSSELine` not found.

**Step 3: Implement `useChat.ts`**

Create `widget/src/hooks/useChat.ts`:

```typescript
import { useState, useCallback, useRef } from 'preact/hooks'

export interface DocumentSource {
  filename: string
  score:    number
}

export interface Message {
  id:       string
  role:     'user' | 'assistant'
  content:  string
  sources?: DocumentSource[]
  isTyping?: boolean
}

type ActionEvent =
  | { kind: 'navigate'; url: string }
  | { kind: 'open_tab'; url: string }
  | { kind: 'http';     name: string; requiresConfirmation: boolean }

type SSEEvent =
  | { type: 'sources'; data: DocumentSource[] }
  | { type: 'delta';   text: string }
  | { type: 'done';    messageId: string; conversationId: string }
  | { type: 'action';  action: ActionEvent }
  | { type: 'error';   message: string }

/** Exported for testing */
export function parseSSELine(line: string): SSEEvent | null {
  if (!line.startsWith('data: ')) return null
  try {
    return JSON.parse(line.slice(6)) as SSEEvent
  } catch {
    return null
  }
}

function generateId(): string {
  return Math.random().toString(36).slice(2, 10)
}

export interface ChatConfig {
  apiKey:      string
  projectId:   string
  baseUrl:     string
  onNavigate?: (url: string) => void
}

export function useChat(config: ChatConfig) {
  const [messages,    setMessages]    = useState<Message[]>([])
  const [isStreaming, setIsStreaming] = useState(false)
  const [error,       setError]       = useState<string | null>(null)
  const conversationIdRef             = useRef<string | null>(
    sessionStorage.getItem(`imply-conv-${config.projectId}`)
  )

  const sendMessage = useCallback(async (text: string): Promise<void> => {
    if (isStreaming || !text.trim()) return
    setError(null)
    setIsStreaming(true)

    // Add user message
    const userMsg: Message = { id: generateId(), role: 'user', content: text.trim() }
    setMessages(prev => [...prev, userMsg])

    // Add typing placeholder
    const assistantId = generateId()
    setMessages(prev => [...prev, { id: assistantId, role: 'assistant', content: '', isTyping: true }])

    try {
      const res = await fetch(`${config.baseUrl}/api/chat`, {
        method:  'POST',
        headers: {
          'Content-Type':        'application/json',
          'X-Imply-Project-Key': config.apiKey,
        },
        body: JSON.stringify({
          projectId:      config.projectId,
          message:        text.trim(),
          conversationId: conversationIdRef.current ?? undefined,
        }),
      })

      if (!res.ok || !res.body) {
        throw new Error(`Request failed (${res.status})`)
      }

      const reader  = res.body.getReader()
      const decoder = new TextDecoder()
      let   buffer  = ''
      let   sources: DocumentSource[] = []

      while (true) {
        const { done, value } = await reader.read()
        if (done) break

        buffer += decoder.decode(value, { stream: true })
        const lines = buffer.split('\n')
        buffer = lines.pop() ?? ''

        for (const line of lines) {
          const event = parseSSELine(line.trim())
          if (!event) continue

          if (event.type === 'sources') {
            sources = event.data
          } else if (event.type === 'delta') {
            setMessages(prev => prev.map(m =>
              m.id === assistantId
                ? { ...m, content: m.content + event.text, isTyping: false }
                : m
            ))
          } else if (event.type === 'done') {
            conversationIdRef.current = event.conversationId
            sessionStorage.setItem(`imply-conv-${config.projectId}`, event.conversationId)
            setMessages(prev => prev.map(m =>
              m.id === assistantId ? { ...m, sources, isTyping: false } : m
            ))
          } else if (event.type === 'action') {
            dispatchAction(event.action, config.onNavigate)
          } else if (event.type === 'error') {
            throw new Error(event.message)
          }
        }
      }
    } catch (err) {
      const msg = err instanceof Error ? err.message : 'Something went wrong. Try again.'
      setError(msg)
      setMessages(prev => prev.filter(m => m.id !== assistantId))
    } finally {
      setIsStreaming(false)
    }
  }, [isStreaming, config])

  return { messages, isStreaming, error, sendMessage }
}

function dispatchAction(
  action: ActionEvent,
  onNavigate?: (url: string) => void
): void {
  if (action.kind === 'navigate') {
    if (onNavigate) {
      onNavigate(action.url)
    } else {
      window.location.href = action.url
    }
  } else if (action.kind === 'open_tab') {
    window.open(action.url, '_blank', 'noopener,noreferrer')
  }
  // 'http' kind handled in follow-up (action execution feature)
}
```

**Step 4: Run tests**

```bash
cd widget && pnpm test
```
Expected: 8 tests PASS.

**Step 5: Commit**

```bash
git add widget/src/hooks/ widget/package.json
git commit -m "feat: add useChat hook with SSE parsing and action dispatch"
```

---

## Task 4: Bubble component

**Files:**
- Create: `widget/src/components/Bubble.tsx`

**Step 1: Create `widget/src/components/Bubble.tsx`**

```tsx
import { useEffect, useRef, type JSX } from 'preact/compat'

interface BubbleProps {
  isOpen:   boolean
  position: 'bottom-right' | 'bottom-left'
  onToggle: () => void
}

export function Bubble({ isOpen, position, onToggle }: BubbleProps): JSX.Element {
  const btnRef  = useRef<HTMLButtonElement>(null)
  const pulsed  = useRef(false)

  useEffect(() => {
    if (!pulsed.current && btnRef.current) {
      btnRef.current.classList.add('pulse')
      pulsed.current = true
    }
  }, [])

  const cls = [
    'imply-bubble',
    position === 'bottom-left' ? 'left' : '',
  ].filter(Boolean).join(' ')

  return (
    <button
      ref={btnRef}
      class={cls}
      aria-label={isOpen ? 'Close chat' : 'Open chat'}
      onClick={onToggle}
    >
      {isOpen ? (
        // X icon
        <svg width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
        </svg>
      ) : (
        // Lightning bolt icon
        <svg width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
          <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 13.5l10.5-11.25L12 10.5h8.25L9.75 21.75 12 13.5H3.75z" />
        </svg>
      )}
    </button>
  )
}
```

**Step 2: Commit**

```bash
git add widget/src/components/Bubble.tsx
git commit -m "feat: add widget Bubble component"
```

---

## Task 5: MessageItem + MessageList components

**Files:**
- Create: `widget/src/components/MessageItem.tsx`
- Create: `widget/src/components/MessageList.tsx`

**Step 1: Create `widget/src/components/MessageItem.tsx`**

```tsx
import { useState, type JSX } from 'preact/compat'
import type { Message } from '../hooks/useChat'

interface MessageItemProps {
  message: Message
}

export function MessageItem({ message }: MessageItemProps): JSX.Element {
  const [sourcesOpen, setSourcesOpen] = useState(false)

  if (message.isTyping) {
    return (
      <div class="imply-msg assistant">
        <div class="imply-msg-bubble">
          <div class="imply-typing">
            <span /><span /><span />
          </div>
        </div>
      </div>
    )
  }

  return (
    <div class={`imply-msg ${message.role}`}>
      <div class="imply-msg-bubble">{message.content}</div>

      {message.role === 'assistant' && message.sources && message.sources.length > 0 && (
        <div
          class="imply-sources"
          onClick={() => setSourcesOpen(o => !o)}
        >
          {sourcesOpen ? '▾' : '▸'} {message.sources.length} source{message.sources.length !== 1 ? 's' : ''}
          {sourcesOpen && (
            <div class="imply-sources-list">
              {message.sources.map((s, i) => (
                <div key={i} class="imply-source-item">{s.filename}</div>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  )
}
```

**Step 2: Create `widget/src/components/MessageList.tsx`**

```tsx
import { useEffect, useRef, type JSX } from 'preact/compat'
import type { Message } from '../hooks/useChat'
import { MessageItem } from './MessageItem'

interface MessageListProps {
  messages: Message[]
  error:    string | null
}

export function MessageList({ messages, error }: MessageListProps): JSX.Element {
  const bottomRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    bottomRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [messages])

  return (
    <div class="imply-messages">
      {messages.length === 0 && (
        <p style={{ color: '#999', fontSize: '13px', textAlign: 'center', marginTop: '32px' }}>
          Ask me anything about this product.
        </p>
      )}

      {messages.map(m => (
        <MessageItem key={m.id} message={m} />
      ))}

      {error !== null && (
        <div class="imply-error">{error}</div>
      )}

      <div ref={bottomRef} />
    </div>
  )
}
```

**Step 3: Commit**

```bash
git add widget/src/components/MessageItem.tsx widget/src/components/MessageList.tsx
git commit -m "feat: add widget MessageItem and MessageList components"
```

---

## Task 6: InputBar component

**Files:**
- Create: `widget/src/components/InputBar.tsx`

**Step 1: Create `widget/src/components/InputBar.tsx`**

```tsx
import { useState, useRef, type JSX } from 'preact/compat'

interface InputBarProps {
  isStreaming: boolean
  onSend:      (text: string) => void
}

export function InputBar({ isStreaming, onSend }: InputBarProps): JSX.Element {
  const [value, setValue] = useState('')
  const ref               = useRef<HTMLTextAreaElement>(null)

  function handleKeyDown(e: KeyboardEvent): void {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      submit()
    }
  }

  function submit(): void {
    const text = value.trim()
    if (!text || isStreaming) return
    onSend(text)
    setValue('')
    // Reset height
    if (ref.current) ref.current.style.height = 'auto'
  }

  function handleInput(e: Event): void {
    const ta = e.currentTarget as HTMLTextAreaElement
    setValue(ta.value)
    // Auto-grow
    ta.style.height = 'auto'
    ta.style.height = `${Math.min(ta.scrollHeight, 96)}px`
  }

  return (
    <div class="imply-input-bar">
      <textarea
        ref={ref}
        class="imply-textarea"
        placeholder="Type a message..."
        value={value}
        disabled={isStreaming}
        rows={1}
        onInput={handleInput}
        onKeyDown={handleKeyDown}
      />
      <button
        class="imply-send-btn"
        disabled={isStreaming || !value.trim()}
        onClick={submit}
        aria-label="Send"
      >
        <svg width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M6 12L3.269 3.126A59.768 59.768 0 0121.485 12 59.77 59.77 0 013.269 20.876L5.999 12zm0 0h7.5" />
        </svg>
      </button>
    </div>
  )
}
```

**Step 2: Commit**

```bash
git add widget/src/components/InputBar.tsx
git commit -m "feat: add widget InputBar component"
```

---

## Task 7: Drawer component

**Files:**
- Create: `widget/src/components/Drawer.tsx`

**Step 1: Create `widget/src/components/Drawer.tsx`**

```tsx
import type { JSX } from 'preact/compat'
import type { Message } from '../hooks/useChat'
import { MessageList } from './MessageList'
import { InputBar } from './InputBar'

interface DrawerProps {
  isOpen:      boolean
  title:       string
  position:    'bottom-right' | 'bottom-left'
  messages:    Message[]
  isStreaming: boolean
  error:       string | null
  onClose:     () => void
  onSend:      (text: string) => void
}

export function Drawer({
  isOpen,
  title,
  position,
  messages,
  isStreaming,
  error,
  onClose,
  onSend,
}: DrawerProps): JSX.Element {
  const cls = [
    'imply-drawer',
    isOpen ? 'open' : '',
    position === 'bottom-left' ? 'left' : '',
  ].filter(Boolean).join(' ')

  return (
    <div class={cls} aria-hidden={!isOpen}>
      {/* Header */}
      <div class="imply-header">
        <span class="imply-header-title">{title}</span>
        <div class="imply-header-actions">
          <button
            class="imply-header-btn"
            onClick={onClose}
            aria-label="Close chat"
          >
            <svg width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
      </div>

      <MessageList messages={messages} error={error} />

      <InputBar isStreaming={isStreaming} onSend={onSend} />
    </div>
  )
}
```

**Step 2: Commit**

```bash
git add widget/src/components/Drawer.tsx
git commit -m "feat: add widget Drawer component"
```

---

## Task 8: Entry point + mount

**Files:**
- Create: `widget/src/index.ts`

**Step 1: Create `widget/src/index.ts`**

```typescript
import { render, h } from 'preact'
import { useState, useCallback }  from 'preact/hooks'
import type { JSX }               from 'preact/compat'
import { STYLES }                 from './styles'
import { Bubble }                 from './components/Bubble'
import { Drawer }                 from './components/Drawer'
import { useChat }                from './hooks/useChat'

// ---- Types -----------------------------------------------------------------

interface ImplyConfig {
  apiKey:      string
  projectId:   string
  title?:      string
  position?:   'bottom-right' | 'bottom-left'
  onNavigate?: (url: string) => void
}

declare global {
  interface Window {
    ImplyConfig?: ImplyConfig
    Imply?: {
      open:    () => void
      close:   () => void
      destroy: () => void
    }
  }
}

// ---- Root component --------------------------------------------------------

function Widget({ config }: { config: ImplyConfig }): JSX.Element {
  const [isOpen, setIsOpen] = useState(false)

  const { messages, isStreaming, error, sendMessage } = useChat({
    apiKey:      config.apiKey,
    projectId:   config.projectId,
    baseUrl:     '', // same origin
    onNavigate:  config.onNavigate,
  })

  const open    = useCallback(() => setIsOpen(true), [])
  const close   = useCallback(() => setIsOpen(false), [])
  const toggle  = useCallback(() => setIsOpen(o => !o), [])

  // Expose public API
  window.Imply = { open, close, destroy: () => { container.remove() } }

  return (
    <>
      <Bubble
        isOpen={isOpen}
        position={config.position ?? 'bottom-right'}
        onToggle={toggle}
      />
      <Drawer
        isOpen={isOpen}
        title={config.title ?? 'Imply'}
        position={config.position ?? 'bottom-right'}
        messages={messages}
        isStreaming={isStreaming}
        error={error}
        onClose={close}
        onSend={sendMessage}
      />
    </>
  )
}

// ---- Mount -----------------------------------------------------------------

const cfg = window.ImplyConfig

if (!cfg?.apiKey || !cfg?.projectId) {
  console.warn('[Imply] missing apiKey or projectId in window.ImplyConfig')
} else {
  const container = document.createElement('div')
  container.id    = 'imply-root'
  document.body.appendChild(container)

  const shadow = container.attachShadow({ mode: 'open' })

  const style       = document.createElement('style')
  style.textContent = STYLES
  shadow.appendChild(style)

  const mountPoint = document.createElement('div')
  shadow.appendChild(mountPoint)

  render(h(Widget, { config: cfg }), mountPoint)
}
```

**Step 2: Commit**

```bash
git add widget/src/index.ts
git commit -m "feat: add widget entry point with shadow DOM mount"
```

---

## Task 9: Build + verify bundle size

**Step 1: Build the widget**

```bash
pnpm build:widget
```

Expected: `public/widget.js` created with no errors.

**Step 2: Check bundle size**

```bash
wc -c public/widget.js
gzip -c public/widget.js | wc -c
```

Expected: gzipped size < 102400 bytes (100KB). Typical result: ~25-35KB gzipped.

**Step 3: Add CORS header to `/api/chat`**

In `app/api/chat/route.ts`, update the streaming response to include CORS headers. Add to the `headers` object in the `new Response(stream, { headers: { ... } })` call:

```typescript
'Access-Control-Allow-Origin':  '*',
'Access-Control-Allow-Headers': 'Content-Type, X-Imply-Project-Key',
```

Also add an OPTIONS handler at the bottom of the file:
```typescript
export async function OPTIONS(): Promise<Response> {
  return new Response(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Origin':  '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, X-Imply-Project-Key',
    },
  })
}
```

**Step 4: Emit `action` SSE events from `/api/chat`**

In `app/api/chat/route.ts`, after streaming completes and `parseActionFromResponse` returns an action, emit it before the `done` event:

```typescript
const action = parseActionFromResponse(fullText)
if (action) {
  controller.enqueue(
    encoder.encode(`data: ${JSON.stringify({ type: 'action', action })}\n\n`)
  )
}
controller.enqueue(
  encoder.encode(`data: ${JSON.stringify({ type: 'done', messageId, conversationId })}\n\n`)
)
```

**Step 5: Run tsc + tests**

```bash
pnpm tsc --noEmit && pnpm vitest run
```

Expected: 0 errors, all tests pass.

**Step 6: Commit**

```bash
git add public/widget.js app/api/chat/route.ts
git commit -m "feat: build widget bundle and add CORS + action SSE to chat API"
```

---

## Task 10: Smoke test

**Step 1: Create a test HTML file**

Create `public/test-widget.html` (do NOT commit this — it is for local testing only):

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Widget Smoke Test</title>
</head>
<body>
  <h1>Widget Smoke Test</h1>
  <p>The chat bubble should appear in the bottom-right corner.</p>

  <script>
    window.ImplyConfig = {
      apiKey:    'REPLACE_WITH_YOUR_API_KEY',
      projectId: 'REPLACE_WITH_YOUR_PROJECT_UUID',
      title:     'Test Chat',
    }
  </script>
  <script src="/widget.js"></script>
</body>
</html>
```

**Step 2: Start dev server and open test page**

```bash
pnpm dev
# open http://localhost:3000/test-widget.html
```

Verify:
- [ ] Black bubble appears bottom-right
- [ ] Clicking bubble opens drawer with slide-up animation
- [ ] Sending a message streams a response token by token
- [ ] Sources chip appears below response
- [ ] Closing drawer works
- [ ] `window.Imply.open()` / `window.Imply.close()` work from browser console
- [ ] Widget styles don't bleed into the test page

**Step 3: Final commit**

```bash
git add public/widget.js app/api/chat/route.ts widget/
git commit -m "feat: complete widget v0.1 — floating bubble, streaming chat, browser actions"
```
